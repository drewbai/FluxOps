stages:
  - validate
  - plan
  - deploy
  - test
  - teardown

variables:
  TF_ROOT: ${CI_PROJECT_DIR}/infra/terraform
  TF_VERSION: "1.5.7"
  AZURE_SUBSCRIPTION_ID: ${AZURE_SUBSCRIPTION_ID}
  ARM_CLIENT_ID: ${ARM_CLIENT_ID}
  ARM_CLIENT_SECRET: ${ARM_CLIENT_SECRET}
  ARM_TENANT_ID: ${ARM_TENANT_ID}
  ARM_SUBSCRIPTION_ID: ${AZURE_SUBSCRIPTION_ID}

# Cache Terraform plugins
cache:
  key: "${CI_COMMIT_REF_SLUG}"
  paths:
    - ${TF_ROOT}/.terraform

# Template for Terraform jobs
.terraform_base:
  image: hashicorp/terraform:${TF_VERSION}
  before_script:
    - cd ${TF_ROOT}
    - terraform --version
    - terraform init -backend=false

# Stage 1: Validate Terraform Configuration
terraform_validate:
  stage: validate
  extends: .terraform_base
  script:
    - terraform fmt -check -recursive
    - terraform validate
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_BRANCH == "develop"'

# Stage 2: Terraform Plan
terraform_plan:
  stage: plan
  extends: .terraform_base
  script:
    - terraform init
    - terraform plan -out=tfplan -input=false
    - terraform show -json tfplan > plan.json
  artifacts:
    paths:
      - ${TF_ROOT}/tfplan
      - ${TF_ROOT}/plan.json
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_BRANCH == "develop"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

# Stage 3: Deploy Infrastructure
terraform_apply:
  stage: deploy
  extends: .terraform_base
  script:
    - terraform init
    - terraform apply -auto-approve -input=false tfplan
    - terraform output -json > terraform_outputs.json
  artifacts:
    paths:
      - ${TF_ROOT}/terraform_outputs.json
    expire_in: 1 month
  dependencies:
    - terraform_plan
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
    - if: '$CI_COMMIT_BRANCH == "develop"'
      when: on_success
  environment:
    name: $CI_COMMIT_BRANCH
    on_stop: terraform_destroy

# Deploy Function App Code
deploy_function_app:
  stage: deploy
  image: mcr.microsoft.com/azure-cli:latest
  before_script:
    - az login --service-principal -u $ARM_CLIENT_ID -p $ARM_CLIENT_SECRET --tenant $ARM_TENANT_ID
    - az account set --subscription $ARM_SUBSCRIPTION_ID
  script:
    - cd ${CI_PROJECT_DIR}/src/function_app
    - pip install --target=".python_packages/lib/site-packages" -r requirements.txt
    - zip -r function_app.zip . -x "*.git*" -x "*__pycache__*" -x "*.pyc"
    - |
      FUNCTION_APP_NAME=$(cat ${TF_ROOT}/terraform_outputs.json | grep -o '"function_app_name":[^,}]*' | cut -d'"' -f4)
      az functionapp deployment source config-zip \
        --resource-group $(cat ${TF_ROOT}/terraform_outputs.json | grep -o '"resource_group_name":[^,}]*' | cut -d'"' -f4) \
        --name $FUNCTION_APP_NAME \
        --src function_app.zip
  dependencies:
    - terraform_apply
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_BRANCH == "develop"'

# Deploy ML Model
deploy_ml_model:
  stage: deploy
  image: python:3.11-slim
  before_script:
    - pip install azure-storage-blob azure-identity scikit-learn pandas numpy joblib
  script:
    - cd ${CI_PROJECT_DIR}/src/ml_pipeline
    - python train_model.py
    - |
      python - <<EOF
      from azure.storage.blob import BlobServiceClient
      from azure.identity import ClientSecretCredential
      import os
      import json
      
      # Read Terraform outputs
      with open('${TF_ROOT}/terraform_outputs.json', 'r') as f:
          outputs = json.load(f)
      
      storage_account = outputs['storage_account_name']['value']
      container_name = outputs['models_container_name']['value']
      
      # Authenticate and upload
      credential = ClientSecretCredential(
          tenant_id=os.environ['ARM_TENANT_ID'],
          client_id=os.environ['ARM_CLIENT_ID'],
          client_secret=os.environ['ARM_CLIENT_SECRET']
      )
      
      blob_service_client = BlobServiceClient(
          account_url=f"https://{storage_account}.blob.core.windows.net",
          credential=credential
      )
      
      # Upload model
      blob_client = blob_service_client.get_blob_client(
          container=container_name,
          blob='model_v1.pkl'
      )
      
      with open('models/model.pkl', 'rb') as data:
          blob_client.upload_blob(data, overwrite=True)
      
      print(f"Model uploaded to {storage_account}/{container_name}/model_v1.pkl")
      EOF
  dependencies:
    - terraform_apply
  artifacts:
    paths:
      - ${CI_PROJECT_DIR}/src/ml_pipeline/models/
      - ${CI_PROJECT_DIR}/src/ml_pipeline/logs/
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_BRANCH == "develop"'

# Stage 4: Test Deployment
test_infrastructure:
  stage: test
  image: mcr.microsoft.com/azure-cli:latest
  before_script:
    - az login --service-principal -u $ARM_CLIENT_ID -p $ARM_CLIENT_SECRET --tenant $ARM_TENANT_ID
    - az account set --subscription $ARM_SUBSCRIPTION_ID
    - apk add --no-cache curl jq
  script:
    - |
      # Read outputs
      RESOURCE_GROUP=$(cat ${TF_ROOT}/terraform_outputs.json | jq -r '.resource_group_name.value')
      STORAGE_ACCOUNT=$(cat ${TF_ROOT}/terraform_outputs.json | jq -r '.storage_account_name.value')
      KEY_VAULT=$(cat ${TF_ROOT}/terraform_outputs.json | jq -r '.key_vault_name.value')
      FUNCTION_APP=$(cat ${TF_ROOT}/terraform_outputs.json | jq -r '.function_app_name.value')
      
      echo "Testing Resource Group..."
      az group show --name $RESOURCE_GROUP --query "properties.provisioningState" -o tsv | grep -q "Succeeded"
      
      echo "Testing Storage Account..."
      az storage account show --name $STORAGE_ACCOUNT --resource-group $RESOURCE_GROUP --query "provisioningState" -o tsv | grep -q "Succeeded"
      
      echo "Testing Key Vault..."
      az keyvault show --name $KEY_VAULT --resource-group $RESOURCE_GROUP --query "properties.provisioningState" -o tsv | grep -q "Succeeded"
      
      echo "Testing Function App..."
      az functionapp show --name $FUNCTION_APP --resource-group $RESOURCE_GROUP --query "state" -o tsv | grep -q "Running"
      
      echo "Testing Function App HTTP endpoint..."
      FUNCTION_URL="https://${FUNCTION_APP}.azurewebsites.net/api/health"
      HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" $FUNCTION_URL || echo "000")
      
      if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "401" ]; then
        echo "Function App is responding (HTTP $HTTP_CODE)"
      else
        echo "Warning: Function App returned HTTP $HTTP_CODE"
      fi
      
      echo "All infrastructure tests passed!"
  dependencies:
    - terraform_apply
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_BRANCH == "develop"'

# Test ML Pipeline
test_ml_pipeline:
  stage: test
  image: python:3.11-slim
  before_script:
    - pip install pytest pytest-cov scikit-learn pandas numpy
  script:
    - cd ${CI_PROJECT_DIR}/src/ml_pipeline
    - pytest tests/ -v --cov=. --cov-report=term --cov-report=html
  artifacts:
    paths:
      - ${CI_PROJECT_DIR}/src/ml_pipeline/htmlcov/
    reports:
      coverage_report:
        coverage_format: cobertura
        path: ${CI_PROJECT_DIR}/src/ml_pipeline/coverage.xml
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_BRANCH == "develop"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

# Stage 5: Teardown (Manual)
terraform_destroy:
  stage: teardown
  extends: .terraform_base
  script:
    - terraform init
    - terraform destroy -auto-approve -input=false
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
    - if: '$CI_COMMIT_BRANCH == "develop"'
      when: manual
  environment:
    name: $CI_COMMIT_BRANCH
    action: stop

# Scheduled cleanup for dev environment
scheduled_cleanup:
  stage: teardown
  extends: .terraform_base
  script:
    - terraform init
    - terraform destroy -auto-approve -input=false
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule" && $CI_COMMIT_BRANCH == "develop"'
